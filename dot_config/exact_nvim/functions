" source: https://github.com/marklee77/mailtools.vim/blob/master/ftplugin/mail.vim
" sidenote: email needs to die in the fire of a 1000 suns. format flowed is
" crap, mildy put.
function! FixFlowed()
    let pos = getpos('.')
    let lnum = pos[1]

    " strip off trailing spaces, except on current line
    execute 'silent! 1;' . (pos[1] - 1) . 's/\m\s*$//'
    execute 'silent! '   . (pos[1] + 1) . ';$s/\m\s*$//'

    " enforce one space after header names
    silent! 1;/\m^$/s/\m^\w\+:\zs\s*\%(\_S\)\@=/ /

    " header lines should end with a space if they flow into the next line
    silent! 1;/\m^$/s/\m\S\zs\%(\_$\n \)\@=/ /

    " put a space back after signature delimiter
    silent! $?\m^--$?s/$/ /

    " compress quote characters
    while search('^>\+\s\+>', 'w') > 0
        silent! s/\m^>\+\zs\s\+>/>/
    endwhile
    silent! %s/\m^>\+\zs\%([^[:space:]>]\)\@=/ /

    " un-space stuff from
    silent! 1/\m^$/;/\m^-- $/s/\m^\s\(\s*\)\zeFrom\_s/\1/

    " put spaces back at ends of lines in paragraph lines, where paragraph lines
    " are defined as lines including at least 2 sequential letters, followed by
    " lines with the same quote prefix (nothing or some number of > followed by
    " a space) that starts with no more than 3 spaces followed by an optional
    " opening punctuation mark, one of "*([{@~|>, that is immediately followed
    " by a letter or digit.
    silent! 1/\m^$/;/\m^-- $/s/\m^\(>\+\s\|\) \{,3}\S*\a\{2,}.*\S\zs\%(\_$\n\1 \{,3}["*(\[{@~|<]\=[0-9A-Za-z]\)\@=/ /

    " space stuff from
    silent! 1/\m^$/;/\m^-- $/s/\m^\ze\s*From\_s/ /

    call setpos('.', pos)
endfunction

function! FixIndented()
  " remove spaces at end of indented lines
  silent! %s/^\s.*\zs \+$//
endfunction

function! InitializeDirectories()
    " decide where our base path is
    let parent = $HOME . '/.cache/nvim'

    " build directory list
    let separator = "."
    " undodir requires vim >= 7.3
    let dir_list = {
            \ 'backup': 'backupdir',
            \ 'views': 'viewdir',
            \ 'swap': 'directory',
            \ 'undo': 'undodir' }

    for [dirname, settingname] in items(dir_list)
      let directory = parent . '/' . dirname . "/"
      if exists("*mkdir")
          if !isdirectory(directory)
              call mkdir(directory, "p", "0700")
          endif
      endif
      if !isdirectory(directory)
          echo "Warning: Unable to create backup directory: " . directory
          echo "Try: mkdir -p " . directory
      else
          let directory = substitute(directory, " ", "\\\\ ", "")
          exec "set " . settingname . "=" . directory
      endif
  endfor
endfunction

fun! InitNewBackupExtension()
    "this keeps a backup every hour on write
    "requires a BufWritePre with a call to this function
      let &bex = '~' . strftime("%Y%m%d%H")
endfun

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_
        \ | diffthis | wincmd p | diffthis
endif


" open a cabling file in a vertical split buffer
function! OpenCabling(institute)
    if !exists("g:cabling_base")
        let g:cabling_base='/opt/cn21/var'
    endif
    let a:path = g:cabling_base . '/i' . a:institute . '/topology'
    let a:loc2noauto = a:path . '/cn21-2loc_cabling.i' . a:institute . '.noAUTO.txt'
    let a:loc2 = a:path . '/cn21-2loc_cabling.i' . a:institute . '.txt'
    let a:loc1noauto = a:path . '/cn21-cabling.i' . a:institute . '.noAUTO.txt'
    let a:loc1 = a:path . '/cn21-cabling.i' . a:institute . '.txt'
    echo a:loc1
    if filereadable(expand(a:loc2noauto))
        let a:cabfile = a:loc2noauto
    elseif filereadable(expand(a:loc2))
        let a:cabfile = a:loc2
    elseif filereadable(expand(a:loc1noauto))
        let a:cabfile = a:loc1noauto
    elseif filereadable(expand(a:loc1))
        let a:cabfile = a:loc1
    endif

    if !exists("a:cabfile")
        echo "No Cablingfile found for " . a:institute
    else
        execute "rightbelow vsplit " . a:cabfile
    endif
endfunction

" run :GoBuild or :GoTestCompile based on the go file
function! BuildGoFiles()
  let l:file = expand('%')
  if l:file =~# '^\f\+_test\.go$'
    call go#cmd#Test(0, 1)
  elseif l:file =~# '^\f\+\.go$'
    call go#cmd#Build(0)
  endif
endfunction
